# 创建型设计模式

## 1 简单工程模式
为什么要使用工厂模式？

&emsp;与一个对象相关的职责通常有三类：对象本身所具有的职责、创建对象的职责和使用对象的职责。对象本身的职责比较容易理解，就是对象自身
所具有的一些数据和行为，可通过一些公开的方法来实现它的职责。在本文中，我们将简单讨论一下对象的创建职责和使用职责。

在Java语言中，我们通常有以下几种创建对象的方式：
- (1) 使用new关键字直接创建对象；
- (2) 通过反射机制创建对象；
- (3) 通过clone()方法创建对象；
- (4) 通过工厂类创建对象。

举例：
```java

class LoginAction {
	private UserDao userDao;
	
	//创建对象(jdbc方式)
	public LoginAction() {
		userDao = new JDBCUserDao();
	}
	
	public void execute() {
		//其他代码
		
		//使用对象
		userDao.findUserById(); 
		
		//其他代码
	}
}
```

&emsp;LoginAction类负责创建了一个UserDAO子类的对象并使用UserDAO的方法来完成相应的业务处理，也就是说LoginAction即负责userDao的创建
又负责userDao的使用，创建对象和使用对象的职责耦合在一起，这样的设计会导致一个很严重的问题：如果在LoginAction中希望能够使用
UserDao的另一个子类如HibernateUserDao类型的对象，必须修改LoginAction类的源代码，违反了“开闭原则”。解决办法引入UserDaoFactory
来负责UserDao的创建工作。

&emsp;在所有的工厂模式中，我们都强调一点：两个类A和B之间的关系应该仅仅是A创建B或是A使用B，而不能两种关系都有。将对象的创建和使用分离，
也使得系统更加符合“单一职责原则”，有利于对功能的复用和系统的维护。

&emsp;此外，将对象的创建和使用分离还有一个好处：防止用来实例化一个类的数据和代码在多个类中到处都是，可以将有关创建的知识搬移到一个
工厂类中，这在《重构与模式》一书中有专门的一节来进行介绍。因为有时候我们创建一个对象不只是简单调用其构造函数，还需要设置一些
参数，可能还需要配置环境，如果将这些代码散落在每一个创建对象的客户类中，势必会出现代码重复、创建蔓延的问题，而这些客户类其实
无须承担对象的创建工作，它们只需使用已创建好的对象就可以了。此时，可以引入工厂类来封装对象的创建逻辑和客户代码的
实例化/配置选项。




## 2 工程方法模式

## 3 抽象工程模式

## 4 单例模式

## 5 原型模式

## 6 建造这模式