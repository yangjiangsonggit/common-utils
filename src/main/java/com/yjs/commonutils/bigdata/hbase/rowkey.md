37.行键设计
37.1。热点发现
HBase中的行按行键按字典顺序排序。该设计针对扫描进行了优化，使您可以将相关的行或将一起读取的行彼此靠近存储。但是，设计不当的行键是引起热点的常见原因。当大量客户端流量定向到群集的一个节点或仅几个节点时，就会发生热点。此流量可能表示读取，写入或其他操作。流量使负责托管该区域的单台计算机不堪重负，从而导致性能下降并可能导致区域不可用。这也可能对由同一区域服务器托管的其他区域产生不利影响，因为该主机无法满足请求的负载。设计数据访问模式非常重要，这样才能充分，均匀地利用群集。

为防止写入时出现热点，请设计行键，以使确实确实需要位于同一区域的行位于，但从更大的角度看，数据被写入集群中的多个区域，而不是一次写入一个区域。下面介绍了一些避免热点的常用技术，以及它们的一些优点和缺点。

盐
从这种意义上讲，加盐与加密无关，而是指将随机数据添加到行密钥的开头。在这种情况下，加盐是指在行键上添加一个随机分配的前缀，以使其与行键的排序方式不同。可能的前缀数量对应于您要分布数据的区域数量。如果您在其他分布更均匀的行中反复出现一些“热”行键模式，则盐析会有所帮助。考虑下面的示例，该示例表明加盐可以将写入负载分散到多个RegionServer中，并说明对读取的某些负面影响。

例子11.加盐例子
假设您具有以下行键列表，并且对表进行了拆分，以使字母表中的每个字母都有一个区域。前缀“ a”是一个区域，前缀“ b”是另一个区域。在此表中，所有以'f'开头的行都在同一区域中。本示例重点介绍具有以下键的行：

foo0001
foo0002
foo0003
foo0004
现在，假设您想将它们分布在四个不同的区域。您决定使用四个不同的盐：a，b，c，和d。在这种情况下，这些字母前缀中的每一个都将位于不同的区域。应用盐后，将改为使用以下行键。由于您现在可以写入四个单独的区域，因此理论上写入时的吞吐量是所有写入相同区域时的吞吐量的四倍。

a-foo0003
b-foo0001
c-foo0004
d-foo0002
然后，如果您添加另一行，则会为该行随机分配四个可能的盐值之一，并最终靠近现有行之一。

a-foo0003
b-foo0001
c-foo0003
c-foo0004
d-foo0002
由于此分配是随机的，因此，如果要按字典顺序检索行，则需要做更多的工作。这样，盐化会尝试增加写入的吞吐量，但会在读取期间增加成本。

散列
可以使用单向哈希来代替给定行，该哈希始终使给定的行使用相同的前缀“加盐”，而不是随机分配，这样可以将负载分散到RegionServer上，但允许在读取过程中进行可预测性。使用确定性哈希可以使客户端重建完整的行键，并使用Get操作正常检索该行。

例子12.散列例子
给定上面盐化示例中的相同情况，您可以改为应用单向哈希，这将导致具有键的行foo0003始终且可预测地接收a前缀。然后，要检索该行，您将已经知道密钥。您还可以优化事物，例如使某些对密钥始终位于同一区域。
倒转钥匙
防止热点的第三个常见技巧是反转固定宽度或数字行键，以使变化最频繁的部分（最低有效位）在第一位。这有效地使行键随机化，但牺牲了行排序属性。

请参阅https://communities.intel.com/community/itpeernetwork/datastack/blog/2013/11/10/discussion-on-designing-hbase-tables以及Phoenix项目中有关咸表的文章，以及评论HBASE-11682的有关避免hotspotting的更多信息。


37.2。单调增加行键/时间序列数据
在汤姆·怀特（Tom White）的书《Hadoop：权威指南》（O'Reilly）的HBase章节中，有一个优化说明，注意当导入过程与所有客户协调一致地敲击表中一个区域时，这种现象（因此是单个节点），然后移至下一个区域，依此类推。随着单调增加行键（即使用时间戳），这种情况将会发生。请参阅IKai Lan的漫画，了解为何在类似BigTable的数据存储区中单调递增的行键会出现问题：单调递增的值很糟糕。可以通过将输入记录随机化为不按排序顺序来缓解单调递增键在单个区域上的堆积，但是通常最好避免使用时间戳或序列（例如1、2、3）作为行键。

如果确实需要将时间序列数据上传到HBase，则应学习OpenTSDB作为成功的示例。它的页面描述了它在HBase中使用的架构。OpenTSDB中的密钥格式实际上是[metric_type] [event_timestamp]，乍一看似乎与先前关于不使用时间戳作为密钥的建议相矛盾。但是，不同之处在于时间戳不在密钥的领先位置，而设计假设是存在数十个或数百个（或更多）不同的度量标准类型。因此，即使连续输入数据流具有多种度量标准类型，Put也会分布在表中区域的各个点上。

有关某些行键设计示例，请参见schema.casestudies。

37.3。尝试最小化行和列的大小
在HBase中，值总是随其坐标一起传送；当单元格值通过系统时，将始终伴随其行，列名和时间戳记。如果行名和列名很大，尤其是与单元格值的大小相比，则可能会遇到一些有趣的情况。Marc Limotte在HBASE-3551的尾部描述了这种情况（推荐！）。其中，保留在HBase存储文件（StoreFile（HFile））以促进随机访问，因为单元值坐标很大，最终可能会占用HBase分配的RAM的大块。上面引用的注释中的Mark建议增加块大小，以便存储文件索引中的条目以较大的间隔发生或修改表模式，从而使行和列名较小。压缩还将使索引更大。请在用户邮件列表中查看有关问题storefileIndexSize的线程。

在大多数情况下，效率低下并不重要。不幸的是，这是他们这样做的情况。无论为ColumnFamilies，属性和行键选择了哪种模式，它们都可以在数据中重复数十亿次。

有关HBase内部存储数据的更多信息，请参见keyvalue，以了解为什么这很重要。

37.3.1。列族
尝试使ColumnFamily名称尽可能的小，最好是一个字符（例如，“ d”表示数据/默认值）。

有关HBase内部存储数据的更多信息，请参见KeyValue，以了解为什么这很重要。

37.3.2。属性
尽管详细的属性名称（例如“ myVeryImportantAttribute”）更易于阅读，但更喜欢使用较短的属性名称（例如“ via”）存储在HBase中。

有关HBase内部存储数据的更多信息，请参见keyvalue，以了解为什么这很重要。

37.3.3。行键长度
使其尽可能短，以使它们仍可用于所需的数据访问（例如，获取与扫描）。对于数据访问无用的短键并不比具有更好的获取/扫描属性的长键更好。设计行键时需要权衡取舍。

37.3.4。字节模式
长为8个字节。您可以在这八个字节中存储最多18,446,744,073,709,551,615个无符号数。如果将此数字存储为字符串（每个字符假定一个字节），则需要将近3倍的字节。

不服气吗？以下是一些可以自己运行的示例代码。

// long
//
long l = 1234567890L;
byte[] lb = Bytes.toBytes(l);
System.out.println("long bytes length: " + lb.length);   // returns 8

String s = String.valueOf(l);
byte[] sb = Bytes.toBytes(s);
System.out.println("long as string length: " + sb.length);    // returns 10

// hash
//
MessageDigest md = MessageDigest.getInstance("MD5");
byte[] digest = md.digest(Bytes.toBytes(s));
System.out.println("md5 digest bytes length: " + digest.length);    // returns 16

String sDigest = new String(digest);
byte[] sbDigest = Bytes.toBytes(sDigest);
System.out.println("md5 digest as string length: " + sbDigest.length);    // returns 26
不幸的是，使用类型的二进制表示形式会使您的数据难以在代码外部读取。例如，这是您在增加值时在外壳中看到的内容：

hbase(main):001:0> incr 't', 'r', 'f:q', 1
COUNTER VALUE = 1

hbase(main):002:0> get 't', 'r'
COLUMN                                        CELL
 f:q                                          timestamp=1369163040570, value=\x00\x00\x00\x00\x00\x00\x00\x01
1 row(s) in 0.0310 seconds
外壳程序会尽力打印字符串，在这种情况下，它决定只打印十六进制。区域名称中的行键也会发生同样的情况。如果您知道要存储的内容，可以这样做，但是如果可以将任意数据放在相同的单元格中，则可能也不可读。这是主要的权衡。


















